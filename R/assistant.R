#' Options used by the gander package
#'
#' @description
#' The gander package makes use of a few notable user-facing options.
#'
#' @section Choosing models:
#'
#' gander uses the `.gander_fn` and `.gander_args` options to configure which
#' model powers the addin. `.gander_fn` is the name of an ellmer `chat_*()`
#' function as a string, and `.gander_args` is a list of arguments to pass to
#' that function. For example, to use OpenAI's GPT-4o-mini, you might write:
#'
#' ```r
#' options(
#'   .gander_fn = "chat_openai",
#'   .gander_args = list(model = "gpt-4o-mini")
#' )
#' ```
#'
#' Paste that code in your `.Rprofile` via `usethis::edit_r_profile()` to always
#' use the same model every time you start an R session.
#'
#' @section Style/taste:
#'
#' By default, gander responses use the following style
#' conventions: "`r default_gander_style()`" Set the `.gander_style` option to
#' some other string to tailor responses to your own taste, e.g.:
#'
#' ```r
#' options(.gander_style = "Use base R.")
#' ```
#'
#' Paste that code in your
#' `.Rprofile` via `usethis::edit_r_profile()` to always use the same style (or
#' even always begin with some base set of knowledge about frameworks you
#' work with often) every time you start an R session.
#'
#' @name gander_options
#' @aliases .gander_fn
#' @aliases .gander_args
#' @aliases .gander_style
NULL

initialize_assistant <- function(context, input) {
  chat <- new_chat()

  system_prompt <- construct_system_prompt(context, input)

  chat$set_system_prompt(system_prompt)

  chat
}

new_chat <- function(
    fn = getOption(".gander_fn", default = "chat_claude"),
    ...,
    .ns = "ellmer"
) {
  args <- list(...)
  default_args <- getOption(".gander_args", default = list())
  args <- modifyList(default_args, args)

  rlang::eval_bare(rlang::call2(fn, !!!args, .ns = .ns))
}

construct_system_prompt <- function(context, input) {
  ext <- file_extension(context$path)

  has_selection <- !identical(context$selection[[1]]$text, "")
  interface <- input$interface

  res <-
    cli::format_inline(c(
      "You are a helpful but terse R data scientist tasked with ",
       "{interface_to_gerund(interface)} code. You will be provided with some ",
       "code context, then some instructions in the form 'Now, [INSTRUCTIONS]', ",
       if (has_selection) {
         c(
           "a selection of code",
           if (!identical(ext, "r")) {" (and possibly backticks and/or exposition)"},
           ", "
         )
       },
       "possibly some additional code context, and then some context ",
       "on the current R environment."
    ))

  if (identical(ext, "r")) {
    res <- c(
      res,
      "",
      "Respond _only_ with valid R code: no exposition, no backticks. "
    )
  } else if (has_selection & identical(interface, "Replace")) {
    # not an R file but we're replacing a selection.
    # have to nail the response format!
    res <- c(
      res,
      cli::format_inline(
        "The format of the selection will determine the format of your response. ",
         "Is the contents of the selection entirely composed of R code? If so, ",
         "reply only with R code. Is the selection surrounded with backticks? ",
         "If so, include backticks in your reply. If not, reply only with the ",
         "R code and no backticks."
      )
    )
  } else {
    # not necessarily an R file and interface could be Prefix or Suffix
    res <- c(
      res,
      cli::format_inline(
        "When asked for code, provide only the requested code, no exposition nor
         backticks, unless explicitly asked. "
      )
    )
  }

  res <- c(
    res,
    "Always provide a minimal solution and refrain from unnecessary additions. ",
    get_gander_style()
  )

  paste(res, collapse = "\n")
}

interface_to_gerund <- function(interface) {
  switch(
    interface,
    Replace = "updating",
    Prefix = "prefixing",
    Suffix = "suffixing"
  )
}

construct_turn <- function(input, context) {
  selection <- rstudioapi::primary_selection(context)[["text"]]

  code_context <- fetch_code_context(context)
  env_context <- fetch_env_context(selection, input$text, env = global_env())

  construct_turn_impl(
    input = input,
    selection = selection,
    code_context = code_context,
    env_context = env_context,
    ext = file_extension(context$path)
  )
}

# all inputs are just character vectors
construct_turn_impl <- function(input, selection, code_context, env_context, ext) {
  res <- paste0("Up to this point, the contents of my ", ext, " file reads: ")
  res <- c(res, "", code_context[["before"]], "")

  if (!identical(selection, "")) {
    res <- c(res, paste0("Now, ", input$text, " in the following selection: "))
    res <- c(res, "", "<selection>", selection, "</selection>", "")
    res <- discourage_backticks(res, selection, input$interface)
  } else {
    res <- c(res, paste0(gsub("\\.$", "", input$text), "."))
  }

  if (!identical(code_context[["after"]], character(0))) {
    res <- c(res, "", "For context, the rest of the file reads: ", "")
    res <- c(res, code_context[["after"]])
  }

  if (!identical(env_context, character(0))) {
    res <- c(res, "", "Here's some information about the objects in my R environment: ")
    res <- c(res, "", env_context, "")
  }

  paste0(res, collapse = "\n")
}

discourage_backticks <- function(res, selection, interface) {
  if (isTRUE(identical(interface, "Replace") &
             !grepl("```", selection, fixed = TRUE))) {
    res <- c(
      res,
      "",
      paste0(
        "Do not include backticks in your response and reply only with the ",
        "updated version of this selection."
      )
    )
  }

  res
}
